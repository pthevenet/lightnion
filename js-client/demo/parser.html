<html>

<head>
    <script src="lightnion.bundle.js"></script>
    <meta charset="UTF-8">
</head>

<body>
    <pre id='loaded'></pre>
    <pre id='log'></pre>

    <script>
        lnn.open('localhost', 4990,
            function success(endpoint) {
                readTextFile('beautify_cons.txt')
                //readTextFile('test.consensus.txt')
            },
            function error(endpoint) {
                console.log("OOPS")
                document.getElementById('loaded').innerHTML = '(unable to open)'
            })

        function consensusParser(rawConsensus) {
            cons = {}

            let consensusByLines = rawConsensus.split("\n")

            consensusByLines = consumeHeaders(cons, consensusByLines)
            console.log(cons)
            console.log(consensusByLines)

            return cons
        }

        function consumeHeaders(cons, consensusByLines) {
            let headers = 'headers'
            let nbrLines = 0
            let atLeastOnce = getAtLeastOnce()[headers]
            let atMostOnce = getAtMostOnce()[headers]


            for (let line of consensusByLines) {

                let splittedLine = line.split(" ")
                let firstWord = splittedLine[0]

                if (firstWord === 'dir-source') {
                    checkIsValid(atLeastOnce)
                    return consensusByLines.slice(nbrLines, consensusByLines.length)

                } else if (firstWord === 'network-status-version') {

                    if (nbrLines !== 0) throw `Error: ${firstWord} must be at start`
                    else if (atLeastOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    checkSizeFormat(splittedLine, 1, firstWord)
                    if (isNaN(splittedLine[1])) throw 'Error: network-status expects a number'

                    cons[headers] = {
                        'network-status-version': {
                            'version': splittedLine[1]
                        }
                    }
                    atLeastOnce[firstWord] = true

                } else if (firstWord === 'vote-status') {

                    if (atLeastOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`
                    checkSizeFormat(splittedLine, 1, firstWord)
                    if (splittedLine[1] !== 'vote' && splittedLine[1] !== 'consensus') throw `Error: ${firstWord} must be either vote or consensus`

                    if (splittedLine[1] === 'consensus') {
                        atLeastOnce['published'] = true
                    }

                    cons[headers][firstWord] = splittedLine[1]

                    atLeastOnce[firstWord] = true

                } else if (firstWord === 'consensus-method') {
                    if (cons[headers]['vote-status'] !== 'consensus') throw `Error: ${firstWord} is a field of consensus`
                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`
                    checkSizeFormat(splittedLine, 1, firstWord)
                    if (isNaN(splittedLine[1])) throw 'Error: consensus-method of consensuses expects a number'

                    cons[headers][firstWord] = splittedLine[1]

                    atMostOnce[firstWord] = true
                } else if (firstWord === 'consensus-methods') {

                    //TODO: Keep eventhough it's a vote field?
                    if (cons[headers]['vote-status'] !== 'vote') throw `Error: ${firstWord} is a field of vote`
                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`
                    
                    let listNbrs = splittedLine.splice(1, splittedLine.length)

                    for (let n of listNbrs) {
                        if (isNaN(n)) throw 'Error: consensus-method of votes expects a list of numbers'
                    }

                    cons[headers][firstWord] = listNbrs
                    atMostOnce[firstWord] = true

                } else if (firstWord === 'valid-after' || firstWord === 'fresh-until' || firstWord === 'valid-until') {
                    //TODO: Check w.r.t current time?

                    if (firstWord === 'published' && cons[headers]['vote-status'] !== 'vote') throw `Error: ${firstWord} is only a field of vote`
                    else if (atLeastOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`
                    checkSizeFormat(splittedLine, 2, firstWord)

                    consumeDateAndTime(firstWord, splittedLine, cons)
                    atLeastOnce[firstWord] = true

                } else if (firstWord === 'voting-delay') {

                    if (atLeastOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    checkSizeFormat(splittedLine, 2, firstWord)
                    if (isNaN(splittedLine[1]) || isNaN(splittedLine[2])) throw 'Error: voting-delay expectes 2 numbers'

                    cons[headers][firstWord] = {
                        'vote': splittedLine[1],
                        'dist': splittedLine[2]
                    }

                    atLeastOnce[firstWord] = true

                } else if (firstWord === 'client-versions' || firstWord === 'server-versions') {

                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    checkSizeFormat(splittedLine, 1, firstWord)
                    let content = splittedLine[1].split(",")
                    cons[headers][firstWord] = content

                    atMostOnce[firstWord]
                } else if (firstWord === 'package') {
                    //TODO: IMPLEMENT IT

                } else if (firstWord === 'known-flags') {
                    if (atLeastOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    let flags = splittedLine.slice(1, splittedLine.length)

                    cons[headers][firstWord] = flags
                    atLeastOnce[firstWord] = true
                } else if (firstWord === 'flag-thresholds') {

                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    if (cons[headers]['vote-status'] !== 'vote') throw `Error: ${firstWord} is only a field of vote`
                    let thresholds = {}

                    for (let threshold of splittedLine.slice(1, splittedLine.length)) {
                        let tmp = threshold.split("=")
                        if (tmp.length !== 2) throw 'Error: malformated flag-threshold'
                        thresholds[tmp[0]] = tmp[1]
                    }

                    cons[headers][firstWord] = thresholds

                    atMostOnce[firstWord] = true
                } else if (firstWord.startsWith('recommended') || firstWord.startsWith('required')) {
                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    cons[headers][firstWord] = parseRanges(splittedLine.splice(1, splittedLine.length))

                    atMostOnce[firstWord] = true
                } else if (firstWord === 'params') {
                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`

                    cons[headers][firstWord] = parseParams(splittedLine.splice(1, splittedLine.length))

                    atMostOnce[firstWord] = true
                } else if (firstWord.startsWith("shared-rand")) {
                    if (atMostOnce[firstWord]) throw `Error: ${firstWord} cannot be twice in the document`
                    checkSizeFormat(splittedLine, 2, firstWord)

                    let reveals = Number(splittedLine[1])
                    let value = splittedLine[2]

                    cons[headers][firstWord] = {
                        'NumReveals': reveals,
                        'Value': value
                    }

                    atMostOnce[firstWord] = true

                } else if (firstWord === 'bandwidth-file-headers') {
                    //TODO: only for vote
                }


                nbrLines += 1
            }

        }

        function checkIsValid(atLeastOnce) {
            for (let field in atLeastOnce) {
                if (!atLeastOnce[field]) throw `Error: ${field} has not been parsed and is mandatory`
            }
        }

        /**
        * This functions created a map of all fields that must be parsed at least once (once or more)
        * i.e the fields that are marked as Exactly once or once or more in the spec
        */
        function getAtLeastOnce() {

            return {
                'headers': {
                    'network-status-version': false,
                    'vote-status': false,
                    'published': false, //TODO: set to true if consensus
                    'valid-after': false,
                    'fresh-until': false,
                    'valid-until': false,
                    'voting-delay': false,
                    'known-flags': false
                },
                'authority_vote': {
                    'dir-sources': false,
                    'contact': false
                },
                'authority_cons': {
                    'dir-sources': false,
                    'contact': false,
                    'vote-digest': false,
                },
                'routers': {
                    'r': false,
                    's': false
                },
                'footer': {
                    'directory-signatures': false
                }
            }

        }
        /**
        * This functions created a map of all fields that must be parsed at most once and a boolean that indicates if it is the case
        * i.e the fields that are marked as at most once in the spec
        */
        function getAtMostOnce() {
            return {
                'headers': {
                    'consensus-methods': false,
                    'consensus-method': false,
                    'client-versions': false,
                    'server-versions': false,
                    'flag-thresholds': false,
                    'recommended-client-protocols': false,
                    'recommended-relay-protocols': false,
                    'required-client-protocols': false,
                    'required-relay-protocols': false,
                    'params': false,
                    'shared-rand-previous-value': false,
                    'shared-rand-current-value': false,
                    'bandwidth-file-headers': false
                },
                'authority_vote': {
                    'legacy-dir-key': false,
                    'shared-rand-participate': false,
                    'shared-rand-previous-value': false,
                    'shared-rand-current-value': false
                },
                'routers': {
                    'v': false,
                    'pr': false,
                    'w': false,
                    'p': false
                },
                'footer': {
                    'bandwidth-weights': false,
                }
            }
        }

        /**
        * Parse the field params of the consensus
        * @param: params        Array of the parameter => Keyword=Int32
        */
        function parseParams(params) {
            let content = {}
            for (let param of params) {
                let tmp = param.split('=')
                content[tmp[0]] = Number(tmp[1])
            }

            return content
        }

        /**
        * Parse the ranges of the protocols
        * @param: pairs         Array of entries => Keyword=Values where values is the range
        */
        function parseRanges(pairs) {
            let content = {}

            for (let pair of pairs) {
                if (pair.includes("=")) {
                    let tmp = pair.split("=")
                    content[tmp[0]] = parse_range_once(tmp[1])
                }
            }

            return content
        }

        /**
        * Helper function to parse the ranges of the protocols
        * params:value      the range we want to parse
        */
        function parse_range_once(value) {
            value = value.split(',')
            subvalues = []

            for (let subvalue of value) {
                if (subvalue.includes('-')) {
                    let lowHigh = subvalue.split('-')
                    let low = Number(lowHigh[0])
                    let high = Number(lowHigh[1])

                    if (low === high - 1) {
                        subvalues.push([low, high])
                    } else {
                        subvalues.push([[low, high]])
                    }
                } else {
                    subvalues.push([Number(subvalue)])
                }
            }

            return subvalues
        }


        /**
         * Consume the date and time for the categories valid-after, fresh-until and valid-until
         * 
         * @param   category            The category we want to consume
         * @param   splittedLine        The line that must be consumed
         * @param   cons                The consensus that is being built
         */
        function consumeDateAndTime(category, splittedLine, cons) {

            checkSizeFormat(splittedLine, 2, category)
            if (!isValidDate(splittedLine[1])) throw `Error: wrong format for the date ${splittedLine[1]} in ${category}`
            if (!isValidTime(splittedLine[2])) throw `Error: wrong format for the time ${splittedLine[2]} in ${category}`

            cons['headers'][category] = {
                "date": splittedLine[1],
                "time": splittedLine[2]
            }
        }

        /**
         * Check if the string in date has the format YYYY-MM-DD
         * @param date          String representing the date
         */
        function isValidDate(date) {
            if (typeof date !== 'string') return false
            let regex = /^\d{4}[-](0[1-9]|1[012])[-](0[1-9]|[12][0-9]|3[01])$/
            return regex.test(date)
        }

        /**Check if the string time has the format HH:MM:SS
         * @param time          String representing the time
         */
        function isValidTime(time) {
            if (typeof time !== 'string') return false
            let regex = /^(0[0-9]|1[0-9]|2[0-3])[:][0-5][0-9][:][0-5][0-9]$/
            return regex.test(time)
        }

        /**
        * Checks if a given line has the good number of argument
        * @param splittedLine   The line to check
        * @param expected       The expected number of argument
        * @param line           The line that throws the expection in the consensus
        */
        function checkSizeFormat(splittedLine, expected, line) {
            if (splittedLine.length !== expected + 1) {
                throw `Error: wrong format for ${line} of the consensus`
            }
        }

        function readTextFile(file) {
            let rawFile = new XMLHttpRequest();
            rawFile.open("GET", file, false);
            rawFile.onreadystatechange = function () {
                if (rawFile.readyState === 4) {
                    if (rawFile.status === 200 || rawFile.status == 0) {
                        cons = consensusParser(rawFile.responseText)
                        console.log(cons)
                    }
                }
            }
            rawFile.send(null);
        }

    </script>
</body>

</html>