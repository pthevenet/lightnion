<html>

<head>
  <script src="lightnion.bundle.js"></script>
  <meta charset="UTF-8">
</head>

<body>
  <p id="status"></p>
  <p id="guard">Guard: waiting...</p>
  <p id="middle">Middle: waiting...</p>
  <p id="exit">Exit: waiting...</p>
  <script>
    lnn.open('localhost', 4990,
      end => {
        if (end.state != lnn.state.success) return
        document.getElementById('status').textContent = "Chanel opened"

        lnn.get.consensus(end,
          end => {
            document.getElementById('status').textContent = "Consensus downloaded"

            lnn.get.descriptors(end, end => {
              //build a hashmap of descriptor where the keys are the identity
              let descriptorsMap = {}

              for (let descriptor of end.descriptors) {
                let identity = descriptor['router'].identity
                descriptorsMap[identity] = descriptor
              }

              //pre-process consensus by filering the routers that do not obey
              //the minimal constraints
              let consensus = end.consensus['routers'].filter(r => !obeyMinimalConstraints(r, descriptorsMap))

              //path selection
              let exitDescriptor = chooseGoodExit(consensus, descriptorsMap)
              document.getElementById('exit').textContent = "Exit: " + exitDescriptor['router'].nickname

              let guardDecriptor = chooseGoodGuard(consensus, exitDescriptor, descriptorsMap)
              document.getElementById('guard').textContent = "Guard: " + guardDecriptor['router'].nickname

              let middleDecriptor = chooseGoodMiddle(consensus, guardDecriptor, exitDescriptor, descriptorsMap)
              document.getElementById('middle').textContent = "Middle: " + middleDecriptor['router'].nickname

            }, error)
          }, error)
      }, error)

    function error(endpoint) {
      document.getElementById('status').textContent = "Something went wrong"
    }

    //--------------------------UTILS---------------------------------------
     
    function obeyMinimalConstraints(router, descriptorsMap) {
      let des = descriptorsMap[router['identity']]
      let flags = router['flags']

      if (!flags.includes("Valid")) return false
      if (!flags.includes("Running")) return false
      if (!router['version'].startsWith("TOR 0.3.")) return false
      if (router['digest'] !== des['digest']) return false
      if (des['identity']['type'] !== 'ed25519') return false

      return true
    }

    function weightedRandomChoice(candidates, descriptorsMap) {
      let total = candidates.reduce((acc, r) => acc + descriptorsMap[r['identity']]['bandwidth']['avg'],0)
      let r = random(total)
      let upto = 0

      for (let router of candidates) {
        let des = descriptorsMap[router['identity']]
        let bandwidth = des['bandwidth']['avg']

        if (upto + bandwidth >= r) return des
        else upto += bandwidth
      }

    }

    function inSame16Subnet(des1, des2 ) {
      let addr1 = des1['router']['address'].split(".")
      let addr2 = des2['router']['address'].split(".")

      return addr1[0] === addr2[0] && addr1[1] === addr2[1]
    }

    function inSameFamily(des1, des2) {
      if (des1['family'] != undefined && des2['family'] != undefined) {
        for (let fam of des1['family']) {
          if (des2['family'].includes(fam)) return true
        }
      }

      return false
    }

    function random(max) {
      return Math.random() * max
    }

    //------------------------------ EXIT ---------------------------------

    function chooseGoodExit(consensus, descriptorsMap) {
      let candidates = consensus.filter(isGoodExit)
      return weightedRandomChoice(candidates, descriptorsMap)
    }

    function isGoodExit(router) {
      let flags = router['flags']
      if (!flags.includes('Exit') || flags.includes('BadExit')) return false
      if (router['exit-policy']['type'] !== 'accept') return false

      return true

    }

    //---------------------------GUARD-------------------------------------
    function chooseGoodGuard(consensus, exitDescriptor, descriptorsMap) {
      let candidates = consensus.filter(r => isGoodGuard(r, exitDescriptor, descriptorsMap))
      return weightedRandomChoice(candidates, descriptorsMap)
    }

    function isGoodGuard(router, exitDescriptor, descriptorsMap){
      let flags = router['flags']
      let des = descriptorsMap[router.identity]

      if(!flags.includes('Guard')) return false
      if(!flags.includes('Stable')) return false
      if(!flags.includes('V2Dir')) return false
      //if(inSame16Subnet(des, exitDescriptor) return false
      if(inSameFamily(des, exitDescriptor)) return false

      return true
    }

    //------------------------MIDDLE-------------------------------------------
    function chooseGoodMiddle(consensus, guardDecriptor, exitDescriptor, descriptorsMap){
      let candidates = consensus.filter(r => isGoodMiddle(r, guardDecriptor, exitDescriptor, descriptorsMap))
      return weightedRandomChoice(candidates, descriptorsMap)
    }

    function isGoodMiddle(router, guardDecriptor, exitDescriptor, descriptorsMap){
      let des = descriptorsMap[router.identity]
      //if(inSame16Subnet(des, guardDecriptor)) return false
      //if(inSame16Subnet(des, exitDescriptor)) return false
      if(inSameFamily(des, guardDecriptor)) return false
      if(inSameFamily(des, exitDescriptor)) return false

      return true
    }


  </script>
</body>

</html>
