<html>

<head>
    <script src="http://peterolson.github.com/BigInteger.js/BigInteger.min.js"></script>
    <script src="lightnion.bundle.js"></script>
    <meta charset="UTF-8">
</head>

<body>
    <p id="result"></p>
    <script>
        
        //Demo of the signature verification of the consensus
        read_text_file("consensus.txt", cons => {
            read_text_file("authority_signing_keys.json", keys => {
                let nbr_verified = 0
                let total = 0

                //get the hash of the consensus
                let split_cons = cons.split('directory-signature ')
                cons = split_cons[0] + "directory-signature "
                let hash = sjcl.hash.sha1.hash(cons)
                hash = sjcl.codec.hex.fromBits(hash)

                // Get the signatures and the signing keys
                keys = JSON.parse(keys)
                let sig_and_keys_digests = get_sig_and_keys_digests(split_cons.splice(1))

                for (let fingerprint in sig_and_keys_digests) {
                    total++
                    //get keys information
                    let key = keys[fingerprint]
                    let e = bigInt(key["exponent"])
                    let n = bigInt(key["modulus"])
                    let key_digest = sig_and_keys_digests[fingerprint]["signing-key-digest"]

                    if (key === undefined || !verify_key(key["pem"], key_digest)) continue

                    let signature = sig_and_keys_digests[fingerprint]["signature"]
                    let sig_big_int = get_signature_big_int(signature)
                    let padded_hash = sig_big_int.modPow(e, n).toString(16)
                    let recovered_hash = get_hash_from_rsa_cipher(padded_hash)

                    nbr_verified = (recovered_hash === undefined || recovered_hash !== hash) ? nbr_verified : nbr_verified + 1
                }

                if (nbr_verified > Math.floor(total / 2)) document.getElementById("result").textContent = `Consensus verified: ${nbr_verified} out of ${total} signatures were verified.`
                else document.getElementById("result").textContent = `Consensus not verified: ${nbr_verified} out of ${total} signatures were verified.`
            })
        })

        /**
         * This function verifies that the key corresponds to one that signed the consensus
         * @param {string} key the key with the format pem
         * @param {string} key_digest the hex digest extracted from the consensus
         **/
        function verify_key(key, key_digest) {
            let raw_key = key.split('\n')
            let b_index = raw_key.indexOf("-----BEGIN RSA PUBLIC KEY-----")
            let e_index = raw_key.indexOf("-----END RSA PUBLIC KEY-----")

            raw_key = raw_key.splice(b_index + 1, e_index - b_index - 1).join("")
            raw_key = sjcl.codec.base64.toBits(raw_key)
            let hash = sjcl.hash.sha1.hash(raw_key)
            hash = sjcl.codec.hex.fromBits(hash)
            return hash.toUpperCase() === key_digest.toUpperCase()
        }


        /**
         * This function gets the signatures and the signing key digests from the authority section of the consensus
         * @param {Array} remaining the remaining part of the consensus after the split by "directory-signature "
         * @returns {object} the following mapping:
         *      fingerprint:{
         *          signature-key-digest
         *          signature
         *      }
         **/
        function get_sig_and_keys_digests(remaining) {
            let sign_and_digests = {}
            for (let r of remaining) {
                if (r !== '') {
                    let split = r.split('\n')
                    let b_index = split.indexOf("-----BEGIN SIGNATURE-----")
                    let e_index = split.indexOf("-----END SIGNATURE-----")
                    let sign = split.splice(b_index + 1, e_index - b_index - 1).join("")
                    let digests = split[0].split(" ")

                    let [fingerprint, key_hex_digest] = (digests.length == 2) ? digests : digests.splice(1)

                    sign_and_digests[fingerprint] = {
                        "signing-key-digest": key_hex_digest,
                        "signature": sign
                    }
                }
            }
            return sign_and_digests
        }
        /**
         * This function transforms a signature in base64 into a bigInteger
         * @param {string} signature the signature encoded in base64
         * returns {BigInteger} the integer corresponding to the signature
         **/
        function get_signature_big_int(signature) {
            let sig_hex = sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(signature))
            let sig = bigInt(sig_hex, 16)
            return sig
        }
        
        /**
         * Verifies that the cipher has the required format and extract the substring corresponding to the hash of the consensus
         * @param {string} cipher the padded hash of the consensus
         * @returns {string} the hash of the consensus
         * */
        function get_hash_from_rsa_cipher(padded_hash) {
            let sep_index = padded_hash.indexOf("00")
            if (!padded_hash.startsWith("1")) return undefined
            for (let i = 1; i < sep_index; i++) {
                if (padded_hash.charAt(i) !== "f") return undefined
            }
            return padded_hash.substring(sep_index + 2)
        }
        
        /**
         * Get a text file from disk
         * @param {string} path the path of the file
         * @param {callback} success the callback called in case of a success
         **/
        function read_text_file(path, success) {
            let rq = new XMLHttpRequest();
            rq.open("GET", path, false);
            rq.onreadystatechange = function () {
                if (rq.readyState === XMLHttpRequest.DONE) {
                    if (rq.status === 200 || rq.status == 0) {
                        let text = rq.responseText
                        success(text)

                    }
                }
            }
            rq.send(null);
        }


    </script>
</body>

</html>